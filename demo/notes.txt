Docker init

set PATH (pwd)/build $PATH
rm -rf ./.docker

running docker init will initialize the .docker directory from a template
templates can be stored in your `~/.docker/project-templates` directory

for example, let's pick a "basic" example

tree -a

.
├── .docker
│   ├── .gitignore
│   ├── config.json
│   └── local
│       └── .keep


The basic example has:

- a config.json to define the project's default cli configuration
- a default .gitignore (more about this later)
- a local directory


Where the config.json at the root of the .docker directory can define settings
that the project author defines, a developer may have their own preferences.

What if, for this project I want experimental CLI features to be enabled?

docker version | grep Experimental

The `local` directory allows local overrides, for example, to override some CLI
settings. By default, the `local` directory is excluded from git, so I don't have
to worry about my personal preferences being committed to source control.

echo '{"experimental":"enabled"}' > ./.docker/local/config.json

This is just to illustrate / explore options that we could consider, and if we extend
the cli configuration with additional options (default namespace/filtering perhaps? only show
images, stacks, containers for a specific project)

So, what could be in a `.docker` directory? Let's pick a slightly extended example:

rm -rf ./.docker

docker init

we pick the "hackit" template

tree -a
.
├── .docker
│   ├── .gitignore
│   ├── buildstack
│   │   ├── Dockerfile.db
│   │   ├── Dockerfile.web
│   │   └── docker-compose.yml
│   ├── config.json
│   ├── dev
│   │   ├── Dockerfile
│   │   └── description.txt
│   ├── local
│   │   └── config.json
│   ├── prod
│   │   ├── Dockerfile
│   │   └── description.txt
│   └── webapp
│       └── docker-compose.yml


Again, this is just exploring options: we could make the CLI more interactive:

- discovering Dockerfiles, compose-files is complicated
- building and running containers often requires various parameters, and typing
  all of those on the command-line is not maintainable. Compose files and `docker app`
  solves some of those, but again, discovering may be a thing
- perhaps we can make this usable for other things (build, buildx, stacks)?


Let's try a build!

docker build
Use the arrow keys to navigate: ↓ ↑ → ←  and / toggles search
Select config?
  ▸ buildstack (db) (Compose File Service)
    buildstack (web) (Compose File Service)
    dev (Dockerfile)
↓   prod (Dockerfile)

Here, we can select what to build:

- different variations or parts of the project
- with a whole directory-structure to play with, we can add more metadata / files
  where needed.
- For example, a description for each of the options

Build the "dev" or "prod" variant

Or perhaps, build a specific service that's defined in a compose file?

Deploying a stack (or "compose project", or "app") could become easier:

docker stack deploy
Use the arrow keys to navigate: ↓ ↑ → ←
Select stack?
  ▸ buildstack
    webapp


Perhaps make `docker run` aware of the project, and allow running a single service
from the stack (interactively), or find all images related to the project:


I only worked on this for a day, so that's all there is for now; hope this can
inspire some ideas though!
